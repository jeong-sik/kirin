(** Angular TypeScript Codegen

    Generate TypeScript types and route definitions from OCaml. *)

(** {1 Route Type Generation} *)

(** Generate TypeScript interface for route params *)
let generate_param_type (route : Route_def.t) =
  let params = route.Route_def.params in
  if params = [] then "Record<string, never>"
  else
    let fields = List.map (fun (p : Route_def.param) ->
      let ts_type = match p.Route_def.param_type with
        | Route_def.String -> "string"
        | Route_def.Int -> "number"
        | Route_def.Uuid -> "string"
        | Route_def.Slug -> "string[]"
        | Route_def.Optional inner ->
          let inner_type = match inner with
            | Route_def.String -> "string"
            | Route_def.Int -> "number"
            | Route_def.Uuid -> "string"
            | _ -> "string"
          in
          inner_type ^ " | undefined"
      in
      Printf.sprintf "  %s: %s;" p.Route_def.name ts_type
    ) params in
    Printf.sprintf "{\n%s\n}" (String.concat "\n" fields)

(** Generate route type definition *)
let generate_route_type (route : Route_def.t) =
  let name = Option.value ~default:"AnonymousRoute" route.Route_def.name in
  let params = generate_param_type route in
  let render_mode = Route_def.render_mode_to_string route.Route_def.render_mode in
  Printf.sprintf {|export interface %sParams %s

export interface %sRoute {
  path: '%s';
  name: '%s';
  params: %sParams;
  renderMode: '%s';
}|} name params name route.path name name render_mode

(** {1 Server Route Config} *)

(** Generate app.routes.server.ts content *)
let generate_server_routes (routes : Route_def.t list) =
  let route_configs = List.map (fun route ->
    let render_mode = match route.Route_def.render_mode with
      | Route_def.Client -> "RenderMode.Client"
      | Route_def.Server -> "RenderMode.Server"
      | Route_def.Prerender -> "RenderMode.Prerender"
    in
    Printf.sprintf "  { path: '%s', renderMode: %s }" route.Route_def.path render_mode
  ) routes in
  Printf.sprintf {|// Auto-generated by Kirin Angular Codegen
import { RenderMode, ServerRoute } from '@angular/ssr';

export const serverRoutes: ServerRoute[] = [
%s
];
|} (String.concat ",\n" route_configs)

(** {1 Component Types} *)

(** Generate component interface *)
let generate_component_type ~name ~inputs ~outputs =
  let input_fields = List.map (fun (prop_name, prop_type, required) ->
    let opt = if required then "" else "?" in
    Printf.sprintf "  @Input() %s%s: %s;" prop_name opt prop_type
  ) inputs in
  let output_fields = List.map (fun (prop_name, event_type) ->
    Printf.sprintf "  @Output() %s = new EventEmitter<%s>();" prop_name event_type
  ) outputs in
  Printf.sprintf {|@Component({
  selector: 'app-%s',
  standalone: true,
  template: ''
})
export class %sComponent {
%s
%s
}|} (String.lowercase_ascii name) name
    (String.concat "\n" input_fields)
    (String.concat "\n" output_fields)

(** {1 Guard Types} *)

(** Generate guard type *)
let generate_guard_type ~name =
  Printf.sprintf {|export const %sGuard: CanActivateFn = (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot
) => {
  // TODO: Implement guard logic
  return true;
};|} name

(** {1 Resolver Types} *)

(** Generate resolver type *)
let generate_resolver_type ~name ~return_type =
  Printf.sprintf {|export const %sResolver: ResolveFn<%s> = (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot
) => {
  // TODO: Implement resolver logic
  return inject(DataService).getData();
};|} name return_type

(** {1 Full Module Generation} *)

(** Generate complete types file *)
let generate_types_file ~routes =
  let route_types = List.filter_map (fun r ->
    match r.Route_def.name with
    | Some _ -> Some (generate_route_type r)
    | None -> None
  ) routes in

  let route_names = List.filter_map (fun r -> r.Route_def.name) routes in
  let route_union = String.concat " | " (List.map (fun n -> Printf.sprintf "'%s'" n) route_names) in

  Printf.sprintf {|// Auto-generated by Kirin Angular Codegen
// Do not edit manually

import { ActivatedRouteSnapshot, RouterStateSnapshot, CanActivateFn, ResolveFn } from '@angular/router';
import { RenderMode, ServerRoute } from '@angular/ssr';

// Route Types
%s

export type RouteName = %s;

// Route Configuration
export interface RouteConfig {
  path: string;
  name?: RouteName;
  component?: any;
  loadComponent?: () => Promise<any>;
  redirectTo?: string;
  pathMatch?: 'full' | 'prefix';
  canActivate?: CanActivateFn[];
  resolve?: Record<string, ResolveFn<any>>;
  children?: RouteConfig[];
  data?: Record<string, any>;
  title?: string;
}

// Typed Router Helper
export function createRoute<T extends RouteName>(
  name: T,
  params?: Record<string, string | number>
): string {
  // Route path generation logic
  return '/' + name;
}
|}
    (String.concat "\n\n" route_types)
    (if route_union = "" then "string" else route_union)

(** {1 Utility} *)

(** Escape TypeScript string *)
let escape_ts_string s =
  s
  |> Str.global_replace (Str.regexp "\\\\") "\\\\\\\\"
  |> Str.global_replace (Str.regexp "'") "\\'"
  |> Str.global_replace (Str.regexp "\n") "\\n"

(** Generate type guard *)
let generate_type_guard ~name ~fields =
  let checks = List.map (fun (field, type_) ->
    Printf.sprintf "typeof obj.%s === '%s'" field type_
  ) fields in
  Printf.sprintf {|export function is%s(obj: unknown): obj is %s {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    %s
  );
}|} name name (String.concat " &&\n    " checks)
