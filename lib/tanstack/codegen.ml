(** TanStack Router Code Generation

    Generate TypeScript types and route definitions. *)

(** {1 TypeScript Generation} *)

(** Generate route params type *)
let generate_params_type (route : Manifest.route_entry) =
  let path = route.path in
  let segments = String.split_on_char '/' path |> List.filter ((<>) "") in
  let params = List.filter_map (fun seg ->
    if String.length seg > 0 && String.get seg 0 = ':' then
      let name = String.sub seg 1 (String.length seg - 1) in
      let is_optional = String.length name > 0 &&
                        String.get name (String.length name - 1) = '?' in
      let name = if is_optional then
          String.sub name 0 (String.length name - 1)
        else name in
      Some (name, is_optional)
    else if String.length seg > 0 && String.get seg 0 = '*' then
      Some ("*", false)
    else
      None
  ) segments in

  if params = [] then "Record<string, never>"
  else
    let fields = List.map (fun (name, optional) ->
      if optional then
        Printf.sprintf "  %s?: string;" name
      else
        Printf.sprintf "  %s: string;" name
    ) params in
    Printf.sprintf "{\n%s\n}" (String.concat "\n" fields)

(** Generate route type for single route *)
let generate_route_type (route : Manifest.route_entry) =
  let params_type = generate_params_type route in
  Printf.sprintf {|
export interface Route_%s {
  id: '%s';
  path: '%s';
  params: %s;
}
|} route.id route.id route.path params_type

(** Generate all route types *)
let generate_route_types (manifest : Manifest.t) =
  let types = List.map generate_route_type manifest.routes in
  String.concat "\n" types

(** Generate route ID union type *)
let generate_route_id_type (manifest : Manifest.t) =
  let ids = List.map (fun r -> Printf.sprintf "  | '%s'" r.Manifest.id) manifest.routes in
  Printf.sprintf "export type RouteId =\n%s;" (String.concat "\n" ids)

(** Generate route tree type *)
let generate_route_tree_type (manifest : Manifest.t) =
  let root_routes = Manifest.root_routes manifest in
  let rec route_to_type route =
    let children = Manifest.children_of route.Manifest.id manifest in
    let children_str = match children with
      | [] -> ""
      | children ->
        let child_types = List.map route_to_type children in
        Printf.sprintf ",\n    children: {\n%s\n    }"
          (String.concat ",\n" child_types)
    in
    Printf.sprintf "    '%s': {\n      path: '%s'%s\n    }"
      route.Manifest.id route.Manifest.path children_str
  in
  let route_types = List.map route_to_type root_routes in
  Printf.sprintf "export interface RouteTree {\n%s\n}"
    (String.concat ",\n" route_types)

(** {1 Full Type File Generation} *)

(** Generate complete TypeScript file *)
let generate_types_file (manifest : Manifest.t) =
  let header = {|/**
 * Auto-generated route types
 * DO NOT EDIT - This file is generated by Kirin TanStack Router
 */

import { createRoute, createRootRoute, createRouter } from '@tanstack/react-router';
|} in

  let route_types = generate_route_types manifest in
  let route_id = generate_route_id_type manifest in
  let route_tree = generate_route_tree_type manifest in

  String.concat "\n\n" [header; route_types; route_id; route_tree]

(** {1 Route Definition Generation} *)

(** Generate route definition *)
let generate_route_definition (route : Manifest.route_entry) =
  let loader_import = if route.has_loader then
    Printf.sprintf "() => import('./%s/loader').then(m => m.loader)" route.id
  else "undefined" in
  Printf.sprintf {|
export const %sRoute = createRoute({
  getParentRoute: () => %s,
  path: '%s',
  loader: %s,
  component: lazy(() => import('./%s/component')),
});
|} route.id
     (match route.parent_id with Some p -> p ^ "Route" | None -> "rootRoute")
     route.path
     loader_import route.id

(** Generate root route *)
let generate_root_route () = {|
export const rootRoute = createRootRoute({
  component: RootLayout,
});
|}

(** Generate router creation *)
let generate_router_creation (manifest : Manifest.t) =
  let route_vars = List.map (fun r -> r.Manifest.id ^ "Route") manifest.routes in
  Printf.sprintf {|
const routeTree = rootRoute.addChildren([
  %s
]);

export const router = createRouter({ routeTree });

declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router;
  }
}
|} (String.concat ",\n  " route_vars)

(** {1 Hook Generation} *)

(** Generate type-safe useParams hook *)
let generate_use_params_hook () = {|
import { useParams as useTanStackParams } from '@tanstack/react-router';

export function useParams<TRouteId extends RouteId>() {
  return useTanStackParams({ from: undefined as unknown as TRouteId });
}
|}

(** Generate type-safe useLoaderData hook *)
let generate_use_loader_data_hook () = {|
import { useLoaderData as useTanStackLoaderData } from '@tanstack/react-router';

export function useLoaderData<TRouteId extends RouteId>() {
  return useTanStackLoaderData({ from: undefined as unknown as TRouteId });
}
|}

(** {1 Full Router File Generation} *)

(** Generate complete router file *)
let generate_router_file (manifest : Manifest.t) =
  let header = {|/**
 * Auto-generated router configuration
 * DO NOT EDIT - This file is generated by Kirin TanStack Router
 */

import { lazy } from 'react';
import { createRoute, createRootRoute, createRouter } from '@tanstack/react-router';
import RootLayout from './layouts/root';
|} in

  let root_route = generate_root_route () in
  let route_defs = List.map generate_route_definition manifest.routes in
  let router_creation = generate_router_creation manifest in

  String.concat "\n" ([header; root_route] @ route_defs @ [router_creation])

(** {1 Search Params Type Generation} *)

(** Generate search params type for route *)
let generate_search_params_type (route_id : string) (params : (string * string) list) =
  if params = [] then
    Printf.sprintf "export type %sSearchParams = Record<string, never>;" route_id
  else
    let fields = List.map (fun (name, ts_type) ->
      Printf.sprintf "  %s?: %s;" name ts_type
    ) params in
    Printf.sprintf "export interface %sSearchParams {\n%s\n}" route_id
      (String.concat "\n" fields)

(** {1 Link Component Type Generation} *)

(** Generate type-safe Link component props *)
let generate_link_props_type (manifest : Manifest.t) =
  let route_unions = List.map (fun r ->
    Printf.sprintf "  | { to: '%s'; params%s: Route_%s['params'] }"
      r.Manifest.path
      (if r.Manifest.path = "/" then "?" else "")
      r.Manifest.id
  ) manifest.routes in
  Printf.sprintf {|
export type LinkProps =
%s;
|} (String.concat "\n" route_unions)
