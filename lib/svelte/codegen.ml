(** Svelte Code Generation

    TypeScript type generation for SvelteKit routes. *)

(** {1 Type Generation} *)

(** Generate TypeScript type for params *)
let generate_param_type params =
  if params = [] then "Record<string, never>"
  else
    let fields = List.map (fun (name, typ) ->
      let ts_type = match typ with
        | "string" -> "string"
        | "int" | "integer" -> "string"  (* Still string in URL *)
        | "uuid" -> "string"
        | "string?" -> "string | undefined"
        | "string[]" -> "string[]"
        | _ -> "string"
      in
      Printf.sprintf "  %s: %s;" name ts_type
    ) params in
    "{\n" ^ String.concat "\n" fields ^ "\n}"

(** Generate route type *)
let generate_route_type (entry : Manifest.route_entry) =
  let params_type = generate_param_type entry.params in
  Printf.sprintf {|export interface Route_%s {
  id: '%s';
  params: %s;
}|}
    (String.map (fun c -> if c = '/' || c = '-' || c = '.' then '_' else c) entry.id)
    entry.id
    params_type

(** Generate all route types *)
let generate_route_types manifest =
  let types = List.map generate_route_type manifest.Manifest.routes in
  String.concat "\n\n" types

(** {1 Load Function Types} *)

(** Generate load function type for route *)
let generate_load_type (entry : Manifest.route_entry) =
  let route_name = String.map (fun c -> if c = '/' || c = '-' || c = '.' then '_' else c) entry.id in
  Printf.sprintf {|export type Load_%s = (event: LoadEvent<Route_%s['params']>) => MaybePromise<Record<string, unknown>>;|}
    route_name route_name

(** Generate all load types *)
let generate_load_types manifest =
  let loads = List.filter (fun (e : Manifest.route_entry) -> e.page) manifest.Manifest.routes in
  let types = List.map generate_load_type loads in
  String.concat "\n" types

(** {1 Action Types} *)

(** Generate action type *)
let generate_action_type (entry : Manifest.route_entry) =
  let route_name = String.map (fun c -> if c = '/' || c = '-' || c = '.' then '_' else c) entry.id in
  Printf.sprintf {|export type Actions_%s = {
  default?: Action<Route_%s['params']>;
  [key: string]: Action<Route_%s['params']> | undefined;
};|}
    route_name route_name route_name

(** Generate all action types *)
let generate_action_types manifest =
  let pages = List.filter (fun (e : Manifest.route_entry) -> e.page) manifest.Manifest.routes in
  let types = List.map generate_action_type pages in
  String.concat "\n\n" types

(** {1 PageData Types} *)

(** Generate PageData type *)
let generate_page_data_type (entry : Manifest.route_entry) =
  let route_name = String.map (fun c -> if c = '/' || c = '-' || c = '.' then '_' else c) entry.id in
  Printf.sprintf {|export interface PageData_%s {
  // Generated from load function return type
  [key: string]: unknown;
}|}
    route_name

(** {1 Router Module} *)

(** Generate router TypeScript file *)
let generate_router_file manifest =
  let routes_array = manifest.Manifest.routes
    |> List.map (fun (e : Manifest.route_entry) ->
      Printf.sprintf {|  {
    id: '%s',
    pattern: '%s',
    page: %b,
    endpoint: %b,
  }|}
        e.id
        e.pattern
        e.page
        e.endpoint
    )
    |> String.concat ",\n"
  in

  Printf.sprintf {|// Auto-generated by Kirin Svelte SSR
// Do not edit manually

import type { LoadEvent, Action, ActionResult } from '@sveltejs/kit';

type MaybePromise<T> = T | Promise<T>;

// Route definitions
export const routes = [
%s
] as const;

// Route type union
export type RouteId = typeof routes[number]['id'];

// Get route by ID
export function getRoute(id: RouteId) {
  return routes.find(r => r.id === id);
}

// Check if route exists
export function hasRoute(id: string): id is RouteId {
  return routes.some(r => r.id === id);
}
|}
    routes_array

(** {1 Full Generation} *)

(** Generate complete types file *)
let generate_types_file manifest =
  Printf.sprintf {|// Auto-generated by Kirin Svelte SSR
// Do not edit manually

import type { LoadEvent, Action, ActionResult } from '@sveltejs/kit';

type MaybePromise<T> = T | Promise<T>;

// =============================================================================
// Route Types
// =============================================================================

%s

// =============================================================================
// Load Function Types
// =============================================================================

%s

// =============================================================================
// Action Types
// =============================================================================

%s
|}
    (generate_route_types manifest)
    (generate_load_types manifest)
    (generate_action_types manifest)

(** {1 File Writing} *)

(** Write generated code to file *)
let write_to_file ~path content =
  let oc = open_out path in
  output_string oc content;
  close_out oc

(** Generate all files *)
let generate ~manifest ~output_dir () =
  (* Router file *)
  let router_content = generate_router_file manifest in
  write_to_file ~path:(Filename.concat output_dir "router.ts") router_content;

  (* Types file *)
  let types_content = generate_types_file manifest in
  write_to_file ~path:(Filename.concat output_dir "types.ts") types_content;

  ()

(** {1 Hooks Generation} *)

(** Generate hooks.server.ts template *)
let generate_hooks_server =
  {|// Auto-generated hooks template
import type { Handle, HandleServerError } from '@sveltejs/kit';

export const handle: Handle = async ({ event, resolve }) => {
  // Add custom logic here
  return resolve(event);
};

export const handleError: HandleServerError = ({ error, event }) => {
  console.error('Server error:', error);
  return {
    message: 'Internal Server Error',
  };
};
|}

(** Generate hooks.client.ts template *)
let generate_hooks_client =
  {|// Auto-generated hooks template
import type { HandleClientError } from '@sveltejs/kit';

export const handleError: HandleClientError = ({ error }) => {
  console.error('Client error:', error);
  return {
    message: 'Something went wrong',
  };
};
|}

(** {1 Layout Types} *)

(** Generate layout data type *)
let generate_layout_type (layout : Manifest.layout_entry) =
  let name = String.map (fun c -> if c = '/' || c = '-' || c = '.' then '_' else c) layout.layout_id in
  Printf.sprintf {|export interface LayoutData_%s {
  // Generated from layout load function
  [key: string]: unknown;
}|}
    name

(** Generate all layout types *)
let generate_layout_types manifest =
  let types = List.map generate_layout_type manifest.Manifest.layouts in
  String.concat "\n\n" types
