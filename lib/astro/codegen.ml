(** Astro TypeScript Codegen

    Generate TypeScript types for Astro projects. *)

(** {1 Type Generation} *)

(** Generate TypeScript type for schema field *)
let rec schema_field_to_ts = function
  | Content.StringField _ -> "string"
  | Content.NumberField _ -> "number"
  | Content.BoolField _ -> "boolean"
  | Content.DateField _ -> "Date"
  | Content.EnumField { values; _ } ->
    let values_str = List.map (Printf.sprintf "\"%s\"") values |> String.concat " | " in
    values_str
  | Content.ArrayField { items; _ } ->
    schema_field_to_ts items ^ "[]"
  | Content.ObjectField _ -> "Record<string, unknown>"
  | Content.ReferenceField { collection; _ } ->
    Printf.sprintf "{ collection: \"%s\"; id: string }" collection
  | Content.ImageField _ -> "{ src: string; width: number; height: number; format: string }"

(** Check if field is required *)
let is_field_required = function
  | Content.StringField { required } -> required
  | Content.NumberField { required; _ } -> required
  | Content.BoolField { required } -> required
  | Content.DateField { required } -> required
  | Content.EnumField { required; _ } -> required
  | Content.ArrayField { required; _ } -> required
  | Content.ObjectField { required; _ } -> required
  | Content.ReferenceField { required; _ } -> required
  | Content.ImageField { required } -> required

(** Generate TypeScript interface for schema *)
let schema_to_ts schema =
  let fields = List.map (fun (name, field) ->
    let optional = if is_field_required field then "" else "?" in
    Printf.sprintf "  %s%s: %s;" name optional (schema_field_to_ts field)
  ) schema.Content.fields |> String.concat "\n" in
  Printf.sprintf "export interface %sSchema {\n%s\n}" schema.Content.name fields

(** Generate TypeScript for collection entry *)
let collection_entry_type collection =
  Printf.sprintf {|export interface %sEntry {
  id: string;
  slug: string;
  body: string;
  collection: "%s";
  data: %sSchema;
  render(): Promise<{ Content: unknown }>;
}|} (String.capitalize_ascii collection.Content.name)
    collection.Content.name
    (String.capitalize_ascii collection.Content.name)

(** {1 Route Types} *)

(** Generate TypeScript for route params *)
let route_params_type route =
  let params = Route_def.get_params route in
  if params = [] then "Record<string, never>"
  else
    let fields = List.map (fun p ->
      Printf.sprintf "  %s: string;" p
    ) params |> String.concat "\n" in
    Printf.sprintf "{\n%s\n}" fields

(** Generate route type *)
let route_to_ts route =
  let path = route.Route_def.path in
  let params = route_params_type route in
  Printf.sprintf {|  "%s": {
    params: %s;
    prerender: %s;
  };|} path params (if route.Route_def.prerender = Route_def.Static then "true" else "false")

(** {1 File Generation} *)

(** Generate types file content *)
let generate_types_file ~routes ~collections =
  let collection_types = List.map (fun c ->
    schema_to_ts c.Content.schema ^ "\n\n" ^ collection_entry_type c
  ) collections |> String.concat "\n\n" in

  let route_types = List.map route_to_ts routes |> String.concat "\n" in

  Printf.sprintf {|// Generated by Kirin Astro - DO NOT EDIT

// Collection Schemas
%s

// Route Types
export interface Routes {
%s
}

// Helper types
export type RouteKey = keyof Routes;
export type RouteParams<K extends RouteKey> = Routes[K]["params"];

// Content helper types
export type CollectionKey = %s;
|}
    collection_types
    route_types
    (if collections = [] then "never"
     else List.map (fun c -> Printf.sprintf "\"%s\"" c.Content.name) collections |> String.concat " | ")

(** Generate routes file *)
let generate_routes_file routes =
  let route_entries = List.map (fun route ->
    let path = route.Route_def.path in
    let prerender = match route.Route_def.prerender with
      | Route_def.Static -> "\"static\""
      | Route_def.OnDemand -> "\"server\""
      | Route_def.Hybrid -> "\"hybrid\""
    in
    Printf.sprintf "  { path: \"%s\", prerender: %s }," path prerender
  ) routes |> String.concat "\n" in

  Printf.sprintf {|// Generated by Kirin Astro - DO NOT EDIT

export const routes = [
%s
] as const;

export type RoutePath = typeof routes[number]["path"];
|} route_entries

(** Generate Astro config *)
let generate_astro_config ~integrations ~output =
  let integration_imports = List.filter_map (fun (i : Integration.t) ->
    match i.config.name with
    | "react" -> Some "import react from '@astrojs/react';"
    | "vue" -> Some "import vue from '@astrojs/vue';"
    | "svelte" -> Some "import svelte from '@astrojs/svelte';"
    | "solid" -> Some "import solid from '@astrojs/solid-js';"
    | "preact" -> Some "import preact from '@astrojs/preact';"
    | "lit" -> Some "import lit from '@astrojs/lit';"
    | "alpinejs" -> Some "import alpine from '@astrojs/alpinejs';"
    | _ -> None
  ) integrations |> String.concat "\n" in

  let integration_calls = List.filter_map (fun (i : Integration.t) ->
    match i.config.name with
    | "react" -> Some "    react(),"
    | "vue" -> Some "    vue(),"
    | "svelte" -> Some "    svelte(),"
    | "solid" -> Some "    solid(),"
    | "preact" -> Some "    preact(),"
    | "lit" -> Some "    lit(),"
    | "alpinejs" -> Some "    alpine(),"
    | _ -> None
  ) integrations |> String.concat "\n" in

  let output_str = match output with
    | Handler.Static -> "static"
    | Handler.Server -> "server"
    | Handler.Hybrid -> "hybrid"
  in

  Printf.sprintf {|// Generated by Kirin Astro - DO NOT EDIT
import { defineConfig } from 'astro/config';
%s

export default defineConfig({
  output: '%s',
  integrations: [
%s
  ],
});
|} integration_imports output_str integration_calls

(** {1 Content Config} *)

(** Generate Zod type for schema field *)
let rec schema_field_to_zod = function
  | Content.StringField _ -> "z.string()"
  | Content.NumberField _ -> "z.number()"
  | Content.BoolField _ -> "z.boolean()"
  | Content.DateField _ -> "z.date()"
  | Content.EnumField { values; _ } ->
    let vals = List.map (Printf.sprintf "\"%s\"") values |> String.concat ", " in
    Printf.sprintf "z.enum([%s])" vals
  | Content.ArrayField { items; _ } ->
    Printf.sprintf "z.array(%s)" (schema_field_to_zod items)
  | Content.ObjectField _ -> "z.record(z.unknown())"
  | Content.ReferenceField _ ->
    "z.object({ collection: z.string(), id: z.string() })"
  | Content.ImageField _ ->
    "z.object({ src: z.string(), width: z.number(), height: z.number(), format: z.string() })"

(** Generate content config - returns Zod schema definition *)
let generate_content_config collections =
  let collection_defs = List.map (fun c ->
    let schema = c.Content.schema in
    let fields = List.map (fun (name, field) ->
      let zod_type = schema_field_to_zod field in
      let optional = if is_field_required field then "" else ".optional()" in
      Printf.sprintf "    %s: %s%s," name zod_type optional
    ) schema.Content.fields |> String.concat "\n" in

    Printf.sprintf {|  %s: {
    type: 'content',
    schema: z.object({
%s
    }),
  },|} c.Content.name fields
  ) collections |> String.concat "\n" in

  Printf.sprintf {|// Generated by Kirin Astro - DO NOT EDIT
// Content collection configuration using Zod schemas
import { z } from 'zod';

export const collections = {
%s
};
|} collection_defs

(** {1 Island Types} *)

(** Generate island component types *)
let generate_island_types islands =
  let island_defs = List.map (fun island ->
    let framework = Island.framework_to_string island.Island.framework in
    Printf.sprintf {|  "%s": {
    component: "%s";
    framework: "%s";
    props: Record<string, unknown>;
  };|} island.Island.id island.Island.component framework
  ) islands |> String.concat "\n" in

  Printf.sprintf {|// Generated by Kirin Astro - DO NOT EDIT

export interface Islands {
%s
}

export type IslandId = keyof Islands;
|} island_defs

(** {1 Env Types} *)

(** Generate env.d.ts *)
let generate_env_dts () =
  {|/// <reference types="astro/client" />

// Generated by Kirin Astro - DO NOT EDIT

interface ImportMetaEnv {
  readonly PUBLIC_SITE_URL: string;
  readonly PUBLIC_API_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
|}
