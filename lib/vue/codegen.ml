(** Vue/Nuxt TypeScript Codegen

    Generate TypeScript types and route definitions from OCaml. *)

(** {1 TypeScript Types} *)

(** Generate TypeScript interface for route params *)
let generate_param_type (route : Route_def.t) =
  let params = route.Route_def.params in
  if params = [] then "Record<string, never>"
  else
    let fields = List.map (fun (p : Route_def.param) ->
      let ts_type = match p.Route_def.param_type with
        | Route_def.String -> "string"
        | Route_def.Int -> "number"
        | Route_def.Uuid -> "string"
        | Route_def.Slug -> "string[]"
        | Route_def.Optional inner ->
          let inner_type = match inner with
            | Route_def.String -> "string"
            | Route_def.Int -> "number"
            | Route_def.Uuid -> "string"
            | _ -> "string"
          in
          inner_type ^ " | undefined"
      in
      Printf.sprintf "  %s: %s;" p.Route_def.name ts_type
    ) params in
    Printf.sprintf "{\n%s\n}" (String.concat "\n" fields)

(** Generate route type definition *)
let generate_route_type (route : Route_def.t) =
  let name = Option.value ~default:"AnonymousRoute" route.Route_def.name in
  let params = generate_param_type route in
  Printf.sprintf {|export interface %sParams %s

export interface %sRoute {
  path: '%s';
  name: '%s';
  params: %sParams;
}|} name params name route.path name name

(** {1 Hook Types} *)

(** Generate useFetch hook types *)
let generate_use_fetch_types () =
  {|export interface FetchOptions<T> {
  key?: string;
  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  query?: Record<string, string>;
  headers?: Record<string, string>;
  body?: any;
  timeout?: number;
  retry?: number | false;
  onRequest?: (ctx: { request: Request }) => void;
  onResponse?: (ctx: { response: Response }) => void;
  transform?: (data: T) => T;
  pick?: (keyof T)[];
}

export interface UseFetchReturn<T> {
  data: Ref<T | null>;
  pending: Ref<boolean>;
  error: Ref<Error | null>;
  refresh: () => Promise<void>;
  execute: () => Promise<void>;
}

export function useFetch<T>(
  url: string | (() => string),
  opts?: FetchOptions<T>
): UseFetchReturn<T>;|}

(** Generate useAsyncData hook types *)
let generate_use_async_data_types () =
  {|export interface AsyncDataOptions<T> {
  key?: string;
  server?: boolean;
  lazy?: boolean;
  immediate?: boolean;
  watch?: WatchSource[];
  default?: () => T | Ref<T>;
  transform?: (data: T) => T;
  pick?: (keyof T)[];
  getCachedData?: (key: string) => T | undefined;
}

export interface AsyncDataReturn<T> {
  data: Ref<T | null>;
  pending: Ref<boolean>;
  error: Ref<Error | null>;
  status: Ref<'idle' | 'pending' | 'success' | 'error'>;
  refresh: () => Promise<void>;
  execute: () => Promise<void>;
  clear: () => void;
}

export function useAsyncData<T>(
  key: string,
  handler: () => Promise<T>,
  opts?: AsyncDataOptions<T>
): AsyncDataReturn<T>;|}

(** {1 Route Generation} *)

(** Generate route manifest TypeScript *)
let generate_routes_file (routes : Route_def.t list) =
  let route_types = List.filter_map (fun r ->
    match r.Route_def.name with
    | Some _ -> Some (generate_route_type r)
    | None -> None
  ) routes in

  let route_names = List.filter_map (fun r -> r.Route_def.name) routes in
  let route_union = String.concat " | " (List.map (fun n -> Printf.sprintf "'%s'" n) route_names) in

  Printf.sprintf {|// Auto-generated by Kirin Vue Codegen
// Do not edit manually

%s

export type RouteName = %s;

export interface RouteLocationRaw {
  name: RouteName;
  params?: Record<string, string | string[]>;
  query?: Record<string, string>;
  hash?: string;
}

export function useRoute<T extends RouteName>(): {
  name: T;
  path: string;
  params: Record<string, string>;
  query: Record<string, string>;
  hash: string;
  fullPath: string;
};

export function useRouter(): {
  push: (to: RouteLocationRaw | string) => Promise<void>;
  replace: (to: RouteLocationRaw | string) => Promise<void>;
  go: (delta: number) => void;
  back: () => void;
  forward: () => void;
};|}
    (String.concat "\n\n" route_types)
    (if route_union = "" then "string" else route_union)

(** {1 API Route Generation} *)

(** Generate API route types *)
let generate_api_types (routes : Action.api_route list) =
  let route_types = List.map (fun (r : Action.api_route) ->
    let method_str = Action.method_to_string r.Action.method_ in
    Printf.sprintf {|export interface API%s%s {
  method: '%s';
  path: '%s';
  params: Record<string, string>;
  response: unknown;
}|} (String.capitalize_ascii (String.lowercase_ascii method_str))
      (String.capitalize_ascii (String.sub r.path 5 (String.length r.path - 5)))
      method_str r.path
  ) routes in
  String.concat "\n\n" route_types

(** {1 Component Types} *)

(** Generate component props type *)
let generate_props_type ~name ~props =
  let fields = List.map (fun (prop_name, prop_type, required) ->
    let opt = if required then "" else "?" in
    Printf.sprintf "  %s%s: %s;" prop_name opt prop_type
  ) props in
  Printf.sprintf "export interface %sProps {\n%s\n}" name (String.concat "\n" fields)

(** Generate page component type *)
let generate_page_type ~name ~props ~meta =
  let props_type = generate_props_type ~name ~props in
  let meta_fields = List.map (fun (key, value) ->
    Printf.sprintf "    %s: %s;" key value
  ) meta in
  Printf.sprintf {|%s

export interface %sMeta {
%s
}

export interface %sPage {
  props: %sProps;
  meta: %sMeta;
}|}
    props_type name (String.concat "\n" meta_fields) name name name

(** {1 Nuxt Config Types} *)

(** Generate nuxt.config types *)
let generate_nuxt_config_types () =
  {|export interface NuxtConfig {
  ssr?: boolean;
  target?: 'server' | 'static';
  app?: {
    head?: {
      title?: string;
      meta?: Array<{ name?: string; property?: string; content: string }>;
      link?: Array<{ rel: string; href: string }>;
      script?: Array<{ src?: string; type?: string }>;
    };
    baseURL?: string;
  };
  runtimeConfig?: {
    public?: Record<string, any>;
    [key: string]: any;
  };
  modules?: string[];
  css?: string[];
  vite?: any;
  nitro?: any;
}

export function defineNuxtConfig(config: NuxtConfig): NuxtConfig;|}

(** {1 Full Module Generation} *)

(** Generate complete types file *)
let generate_types_file ~routes ~api_routes =
  let parts = [
    "// Auto-generated by Kirin Vue Codegen";
    "// Do not edit manually";
    "";
    "import type { Ref, WatchSource } from 'vue';";
    "";
    "// Route Types";
    generate_routes_file routes;
    "";
    "// Fetch Hooks";
    generate_use_fetch_types ();
    "";
    "// Async Data Hooks";
    generate_use_async_data_types ();
    "";
    "// API Routes";
    if api_routes = [] then "// No API routes defined"
    else generate_api_types api_routes;
    "";
    "// Nuxt Config";
    generate_nuxt_config_types ();
  ] in
  String.concat "\n\n" parts

(** {1 Server Route Codegen} *)

(** Generate server route handler type *)
let generate_server_handler_type () =
  {|import type { H3Event } from 'h3';

export interface EventHandler<T = unknown> {
  (event: H3Event): T | Promise<T>;
}

export function defineEventHandler<T>(
  handler: EventHandler<T>
): EventHandler<T>;

export function defineEventHandler<T, R>(
  handler: EventHandler<T>,
  options: { onRequest?: EventHandler; onBeforeResponse?: EventHandler<R> }
): EventHandler<T>;

export function readBody<T>(event: H3Event): Promise<T>;
export function getQuery<T>(event: H3Event): T;
export function getRouterParams(event: H3Event): Record<string, string>;
export function getCookie(event: H3Event, name: string): string | undefined;
export function setCookie(event: H3Event, name: string, value: string, options?: any): void;
export function setHeader(event: H3Event, name: string, value: string): void;
export function sendRedirect(event: H3Event, location: string, code?: number): Promise<void>;
export function createError(options: { statusCode: number; message: string }): Error;|}

(** {1 Utility} *)

(** Escape TypeScript string *)
let escape_ts_string s =
  s
  |> Str.global_replace (Str.regexp "\\\\") "\\\\\\\\"
  |> Str.global_replace (Str.regexp "'") "\\'"
  |> Str.global_replace (Str.regexp "\n") "\\n"

(** Generate type guard *)
let generate_type_guard ~name ~fields =
  let checks = List.map (fun (field, type_) ->
    Printf.sprintf "typeof obj.%s === '%s'" field type_
  ) fields in
  Printf.sprintf {|export function is%s(obj: unknown): obj is %s {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    %s
  );
}|} name name (String.concat " &&\n    " checks)
