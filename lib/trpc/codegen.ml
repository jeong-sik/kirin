(** tRPC Code Generation

    Generate TypeScript client types from router definitions. *)

open Procedure

(** {1 TypeScript Generation} *)

(** Generate TypeScript type from type_info *)
let rec generate_type = function
  | TString -> "string"
  | TInt -> "number"
  | TBool -> "boolean"
  | TNull -> "null"
  | TArray t -> Printf.sprintf "Array<%s>" (generate_type t)
  | TObject fields ->
    let field_strs = List.map (fun (name, t) ->
      Printf.sprintf "  %s: %s;" name (generate_type t)
    ) fields in
    Printf.sprintf "{\n%s\n}" (String.concat "\n" field_strs)
  | TOptional t -> Printf.sprintf "%s | undefined" (generate_type t)
  | TUnion types ->
    String.concat " | " (List.map generate_type types)
  | TCustom name -> name

(** Generate procedure type definition *)
let generate_procedure_type info =
  let input_type = generate_type info.input_type in
  let output_type = generate_type info.output_type in
  let proc_method = match info.proc_type with
    | Query -> "query"
    | Mutation -> "mutate"
    | Subscription -> "subscribe"
  in
  let comment = match info.description with
    | Some desc -> Printf.sprintf "  /** %s */\n" desc
    | None -> ""
  in
  Printf.sprintf "%s  %s: {\n    %s: (input: %s) => Promise<%s>;\n  };"
    comment info.name proc_method input_type output_type

(** {1 Router Type Generation} *)

(** Generate router interface *)
let generate_router_type infos =
  let procedures = List.map generate_procedure_type infos in
  Printf.sprintf "export interface AppRouter {\n%s\n}"
    (String.concat "\n\n" procedures)

(** {1 Input/Output Types} *)

(** Generate all input types *)
let generate_input_types infos =
  let types = List.filter_map (fun info ->
    match info.input_type with
    | TObject _ as t ->
      let name = Printf.sprintf "%sInput" (String.capitalize_ascii info.name) in
      Some (Printf.sprintf "export type %s = %s;" name (generate_type t))
    | _ -> None
  ) infos in
  String.concat "\n\n" types

(** Generate all output types *)
let generate_output_types infos =
  let types = List.filter_map (fun info ->
    match info.output_type with
    | TObject _ as t ->
      let name = Printf.sprintf "%sOutput" (String.capitalize_ascii info.name) in
      Some (Printf.sprintf "export type %s = %s;" name (generate_type t))
    | _ -> None
  ) infos in
  String.concat "\n\n" types

(** {1 Full Client Generation} *)

(** Generate complete TypeScript file *)
let generate_client ~router_name infos =
  let header = Printf.sprintf {|/**
 * Auto-generated tRPC client types
 * DO NOT EDIT - This file is generated by Kirin tRPC
 */

import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
|} in

  let input_types = generate_input_types infos in
  let output_types = generate_output_types infos in
  let router_type = generate_router_type infos in

  let client_factory = Printf.sprintf {|
export function create%sClient(url: string) {
  return createTRPCProxyClient<AppRouter>({
    links: [
      httpBatchLink({
        url,
      }),
    ],
  });
}
|} router_name in

  let parts = [header] in
  let parts = if input_types <> "" then parts @ ["\n// Input Types\n"; input_types] else parts in
  let parts = if output_types <> "" then parts @ ["\n// Output Types\n"; output_types] else parts in
  let parts = parts @ ["\n// Router Type\n"; router_type; client_factory] in
  String.concat "\n" parts

(** {1 Schema Generation} *)

(** Generate JSON Schema from type_info *)
let rec generate_json_schema = function
  | TString -> `Assoc [("type", `String "string")]
  | TInt -> `Assoc [("type", `String "integer")]
  | TBool -> `Assoc [("type", `String "boolean")]
  | TNull -> `Assoc [("type", `String "null")]
  | TArray t ->
    `Assoc [
      ("type", `String "array");
      ("items", generate_json_schema t)
    ]
  | TObject fields ->
    let properties = `Assoc (List.map (fun (name, t) ->
      (name, generate_json_schema t)
    ) fields) in
    let required = `List (List.map (fun (name, _) -> `String name) fields) in
    `Assoc [
      ("type", `String "object");
      ("properties", properties);
      ("required", required)
    ]
  | TOptional t ->
    `Assoc [
      ("oneOf", `List [
        generate_json_schema t;
        `Assoc [("type", `String "null")]
      ])
    ]
  | TUnion types ->
    `Assoc [("oneOf", `List (List.map generate_json_schema types))]
  | TCustom name ->
    `Assoc [("$ref", `String (Printf.sprintf "#/definitions/%s" name))]

(** Generate OpenAPI-style schema for all procedures *)
let generate_schema infos =
  let procedures = List.map (fun info ->
    let proc_type_str = match info.proc_type with
      | Query -> "query"
      | Mutation -> "mutation"
      | Subscription -> "subscription"
    in
    (info.name, `Assoc [
      ("type", `String proc_type_str);
      ("input", generate_json_schema info.input_type);
      ("output", generate_json_schema info.output_type);
      ("description", match info.description with
        | Some d -> `String d
        | None -> `Null);
    ])
  ) infos in
  `Assoc [
    ("procedures", `Assoc procedures);
    ("$schema", `String "https://json-schema.org/draft/2020-12/schema");
  ]

(** {1 Zod Schema Generation} *)

(** Generate Zod schema from type_info *)
let rec generate_zod = function
  | TString -> "z.string()"
  | TInt -> "z.number().int()"
  | TBool -> "z.boolean()"
  | TNull -> "z.null()"
  | TArray t -> Printf.sprintf "z.array(%s)" (generate_zod t)
  | TObject fields ->
    let field_strs = List.map (fun (name, t) ->
      Printf.sprintf "  %s: %s," name (generate_zod t)
    ) fields in
    Printf.sprintf "z.object({\n%s\n})" (String.concat "\n" field_strs)
  | TOptional t -> Printf.sprintf "%s.optional()" (generate_zod t)
  | TUnion types ->
    Printf.sprintf "z.union([%s])" (String.concat ", " (List.map generate_zod types))
  | TCustom name -> name ^ "Schema"

(** Generate Zod schemas for all procedures *)
let generate_zod_schemas infos =
  let schemas = List.map (fun info ->
    let input_schema = Printf.sprintf "export const %sInputSchema = %s;"
        info.name (generate_zod info.input_type) in
    let output_schema = Printf.sprintf "export const %sOutputSchema = %s;"
        info.name (generate_zod info.output_type) in
    input_schema ^ "\n" ^ output_schema
  ) infos in
  "import { z } from 'zod';\n\n" ^ String.concat "\n\n" schemas
