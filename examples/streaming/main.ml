(** Kirin Streaming Example

    Demonstrates high-performance streaming I/O for large data handling.

    Features shown:
    - Chunked response generation
    - Large file download streaming
    - File upload with progress tracking
    - Memory-efficient data processing

    Run with: dune exec examples/streaming/main.exe

    Test endpoints:
    - GET /              - Info page
    - GET /stream        - Stream generated data
    - GET /large-csv     - Stream large CSV (generated)
    - GET /download      - Download a file
    - POST /upload       - Upload a file
*)

open Kirin

(** Generate a large CSV dataset on-the-fly *)
let csv_handler _req =
  Stream.response ~headers:(Http.Header.init ()
    |> fun h -> Http.Header.add h "content-disposition" "attachment; filename=\"data.csv\"")
    (fun yield ->
      (* Header *)
      yield "id,name,value,timestamp\n";

      (* Generate 100,000 rows without loading all into memory *)
      for i = 1 to 100_000 do
        let row = Printf.sprintf "%d,Item_%d,%.2f,%d\n"
          i i (Random.float 1000.0) (int_of_float (Unix.time ()) + i)
        in
        yield row;

        (* Optional: flush every 1000 rows for real-time streaming *)
        if i mod 1000 = 0 then ()
      done
    )
  |> fun resp -> Stream.with_content_type "text/csv" resp

(** Stream generated text data *)
let stream_handler _req =
  Stream.response (fun yield ->
    yield "Starting stream...\n\n";

    for i = 1 to 50 do
      yield (Printf.sprintf "[%d] Processing chunk %d of 50\n" (int_of_float (Unix.time ())) i);
      (* Small delay simulation *)
      Time_compat.sleep 0.02
    done;

    yield "\nStream complete!\n"
  )
  |> fun resp -> Stream.with_content_type "text/plain" resp

(** File download handler *)
let download_handler req =
  let file_param = Kirin.query_opt "file" req in
  match file_param with
  | Some path when Sys.file_exists path ->
    Stream.file_response ~filename:(Filename.basename path) path
  | Some _ ->
    (* For demo, create a temporary file *)
    let content = "This is a sample file content.\nGenerated by Kirin streaming demo.\n" in
    Stream.response (fun yield -> yield content)
    |> Stream.with_header "content-disposition" "attachment; filename=\"sample.txt\""
  | None ->
    Stream.response (fun yield ->
      yield "No file parameter provided.\n";
      yield "Usage: /download?file=/path/to/file\n"
    )

(** Simple upload handler showing file save *)
let upload_handler req =
  let body_size = String.length (Kirin.body req) in

  if body_size = 0 then
    text "No file uploaded. Use POST with file content."
  else begin
    (* For demo, just count bytes without saving *)
    let chunks_count = ref 0 in
    Stream.read_chunks ~request:req ~chunk_size:8192 (fun _chunk ->
      incr chunks_count
    );

    json (`Assoc [
      "status", `String "received";
      "size_bytes", `Int body_size;
      "chunks_processed", `Int !chunks_count;
      "message", `String "File received successfully (not saved in demo)";
    ])
  end

(** JSON streaming - output large JSON array efficiently *)
let json_stream_handler _req =
  Stream.response (fun yield ->
    yield "[\n";

    for i = 1 to 1000 do
      let item = Printf.sprintf {|  {"id": %d, "name": "Item %d", "value": %.2f}|}
        i i (Random.float 100.0)
      in
      if i < 1000 then
        yield (item ^ ",\n")
      else
        yield (item ^ "\n")
    done;

    yield "]\n"
  )
  |> Stream.with_content_type "application/json"

(** Info page *)
let index_handler _req =
  html {|
<!DOCTYPE html>
<html>
<head>
  <title>Kirin Streaming Demo</title>
  <style>
    body { font-family: -apple-system, sans-serif; max-width: 800px; margin: 40px auto; padding: 0 20px; }
    h1 { color: #333; }
    .endpoint { background: #f5f5f5; padding: 15px; margin: 10px 0; border-radius: 8px; }
    .method { display: inline-block; padding: 4px 8px; border-radius: 4px; font-weight: bold; margin-right: 8px; }
    .get { background: #61affe; color: white; }
    .post { background: #49cc90; color: white; }
    code { background: #e8e8e8; padding: 2px 6px; border-radius: 3px; }
    a { color: #0066cc; }
  </style>
</head>
<body>
  <h1>ðŸ¦’ Kirin Streaming Demo</h1>
  <p>High-performance streaming I/O examples using Eio direct-style async.</p>

  <h2>Endpoints</h2>

  <div class="endpoint">
    <span class="method get">GET</span>
    <a href="/stream">/stream</a>
    <p>Stream generated text data in real-time</p>
  </div>

  <div class="endpoint">
    <span class="method get">GET</span>
    <a href="/large-csv">/large-csv</a>
    <p>Download a 100,000 row CSV file (generated on-the-fly, ~4MB)</p>
  </div>

  <div class="endpoint">
    <span class="method get">GET</span>
    <a href="/json-stream">/json-stream</a>
    <p>Stream a large JSON array (1000 items)</p>
  </div>

  <div class="endpoint">
    <span class="method get">GET</span>
    <a href="/download">/download?file=/path</a>
    <p>Download any file with streaming</p>
  </div>

  <div class="endpoint">
    <span class="method post">POST</span>
    /upload
    <p>Upload a file (processed in chunks)</p>
    <code>curl -X POST -d @file.txt http://localhost:8080/upload</code>
  </div>

  <h2>Features</h2>
  <ul>
    <li>âœ… <strong>Memory Efficient</strong> - Files never fully loaded into memory</li>
    <li>âœ… <strong>Chunked Transfer</strong> - Data streams as it's generated</li>
    <li>âœ… <strong>Progress Tracking</strong> - Callbacks for upload/download progress</li>
    <li>âœ… <strong>Backpressure</strong> - Eio flow-based automatic rate control</li>
  </ul>

  <h2>Test with curl</h2>
  <pre><code># Stream text
curl -N http://localhost:8080/stream

# Download CSV
curl -o data.csv http://localhost:8080/large-csv

# Upload file
curl -X POST --data-binary @yourfile.txt http://localhost:8080/upload</code></pre>
</body>
</html>
  |}

(** Convert Stream.t to Response.t for the current server.
    Note: This collects chunks into memory. For true streaming,
    the server would need to support chunked transfer encoding natively. *)
let streaming_handler handler req =
  let stream_resp = handler req in
  Stream.to_response stream_resp

let () =
  (* Initialize random for demo data *)
  Random.self_init ();

  let routes = router [
    get "/" index_handler;
    get "/stream" (fun req -> streaming_handler stream_handler req);
    get "/large-csv" (fun req -> streaming_handler csv_handler req);
    get "/json-stream" (fun req -> streaming_handler json_stream_handler req);
    get "/download" (fun req -> streaming_handler download_handler req);
    post "/upload" upload_handler;
  ] in

  Printf.printf "ðŸ¦’ Kirin Streaming Demo\n";
  Printf.printf "========================\n";
  Printf.printf "Server: http://localhost:8080\n";
  Printf.printf "\nEndpoints:\n";
  Printf.printf "  GET  /           - Info page\n";
  Printf.printf "  GET  /stream     - Stream text data\n";
  Printf.printf "  GET  /large-csv  - Download 100K row CSV\n";
  Printf.printf "  GET  /json-stream - Stream JSON array\n";
  Printf.printf "  GET  /download   - Download file\n";
  Printf.printf "  POST /upload     - Upload file\n";
  Printf.printf "\nPress Ctrl+C to stop\n\n%!";

  start ~port:8080 @@ logger @@ routes
